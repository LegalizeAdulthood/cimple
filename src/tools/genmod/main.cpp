/*
**==============================================================================
**
** Copyright (c) 2003 - 2008, Michael Brasher, Karl Schopmeyer
** Copyright (c) 2007 - 2011 Inova Development Inc.
** Copyright (c) 2009 - 2011 Karl Schopmeyer
** 
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
** SOFTWARE.
**
**==============================================================================
*/
#include <cimple/config.h>
#include <cassert>
#include <getopt.h>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <string>
#include <unistd.h>
#include <util/util.h>
#include <tools/gencommon/gencommon.h>
#include <MOF_Parser.h>
#include <vector>
#include <string>
#include "usage.h"
#include <util/UUID.h>

using namespace std;
bool cmpi_opt = false;
bool pegasus_opt = false;
static string class_list_file;


void gen_comment_line(FILE* os, size_t n)
{
    n -= 2;
    fprintf(os, "//");

    for (size_t i = 0; i < n; i++)
        fputc('=', os);

    fputc('\n', os);
}

void gen_warning(FILE* os)
{
    gen_comment_line(os, 80);
    fprintf(os, "//\n");
    fprintf(os, "// PLEASE DO NOT EDIT; "
        "THIS FILE WAS AUTOMATICALLY GENERATED BY GENMOD %s\n", 
        CIMPLE_VERSION_STRING);
    fprintf(os, "//\n");
    gen_comment_line(os, 80);
    fputc('\n', os);
}

static const char prefix[] = "\
static int __cimple_%s_Provider_proc(\n\
    const Registration* registration,\n\
    int operation,\n\
    void* arg0,\n\
    void* arg1,\n\
    void* arg2,\n\
    void* arg3,\n\
    void* arg4,\n\
    void* arg5,\n\
    void* arg6,\n\
    void* arg7)\n\
{\n\
    typedef %s Class;\n\
    typedef %s_Provider Provider;\n\
\n\
    if (operation != OPERATION_INVOKE_METHOD)\n\
        return %s_Provider_Proc_T<Provider>::proc(registration,\n\
            operation, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n\
\n\
    Provider* provider = (Provider*)arg0;\n\
    const Class* self = (const Class*)arg1;\n\
    const char* meth_name = ((Instance*)arg2)->meta_class->name;\n\
\n";

static const char suffix[] = "\
    return -1;\n\
}\n\
\n";

void write_skeleton(
    FILE* os,
    const char* class_name, 
    const MOF_Method_Decl* meth)
{
    fprintf(os, "    if (strcasecmp(meth_name, \"%s\") == 0)\n", 
        meth->name);
    fprintf(os, "    {\n");

    fprintf(os, "        typedef %s_%s_method Method;\n", 
        class_name, meth->name);

    fprintf(os, "        Method* method = (Method*)arg2;\n");

    fprintf(os, "        return provider->%s(\n", meth->name);

    if (!(meth->qual_mask & MOF_QT_STATIC))
        fprintf(os, "            self,\n");

    for (MOF_Parameter* p = meth->parameters; p; p = (MOF_Parameter*)p->next)
    {
        fprintf(os, "            method->%s", p->name);
        fprintf(os, ",\n");
    }

    fprintf(os, "            method->return_value);\n");

    fprintf(os, "    }\n\n");
}

static void write_proc(FILE* os, const MOF_Class_Decl* cd)
{
    // Write prefix:

    const char* cn = cd->name;
    const char* pt;

    if (cd->qual_mask & MOF_QT_ASSOCIATION)
        pt = "Association";
    else if (cd->qual_mask & MOF_QT_INDICATION)
        pt = "Indication";
    else
        pt = "Instance";

    fprintf(os, prefix, cn, cn, cn, pt);

    // Write methods:

    MOF_Feature_Info* p = cd->all_features;

    for (; p; p = (MOF_Feature_Info*)p->next)
    {
        MOF_Method_Decl* meth = dynamic_cast<MOF_Method_Decl*>(p->feature);

        if (!meth)
            continue;

        write_skeleton(os, cn, meth);
    }

    // Write suffix:

    fprintf(os, "%s", suffix);
}

#if defined(CIMPLE_WINDOWS)

static void gen_guid(const char* module_name, const cimple::UUID& uuid)
{
    const char* fn = "guid.h";

    if (exists(fn))
    {
        printf("Skipped %s (already exists)\n", fn);
        return;
    }

    FILE* os = fopen(fn, "w");

    if (!os)
        err("failed to create \"%s\"", fn);

    const unsigned char *p = uuid.data;
    fprintf(os, "// {%02x%02x%02x%02x-"
        "%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x}\n",
        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
        p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);

    fprintf(os, "DEFINE_GUID(\n");
    fprintf(os, "  CLSID_%s_Module,\n", module_name);
    fprintf(os, "  0x%02x%02x%02x%02x,\n", p[0], p[1], p[2], p[3]);
    fprintf(os, "  0x%02x%02x,\n", p[4], p[5]);
    fprintf(os, "  0x%02x%02x,\n", p[6], p[7]);
    fprintf(os, "  0x%02x,\n", p[8]);
    fprintf(os, "  0x%02x,\n", p[9]);
    fprintf(os, "  0x%02x,\n", p[10]);
    fprintf(os, "  0x%02x,\n", p[11]);
    fprintf(os, "  0x%02x,\n", p[12]);
    fprintf(os, "  0x%02x,\n", p[13]);
    fprintf(os, "  0x%02x,\n", p[14]);
    fprintf(os, "  0x%02x);\n", p[15]);

    printf("Created %s\n", fn);
}

static void gen_register(const char* module_name, const cimple::UUID& uuid)
{
    // Open file:

    const char* fn = "register.mof";

    if (exists(fn))
    {
        printf("Skipped %s (already exists)\n", fn);
        return;
    }

    FILE* os = fopen(fn, "w");

    if (!os)
        err("failed to create \"%s\"", fn);

    // Format guid:

    const unsigned char *p = uuid.data;
    char buf[1024];
    sprintf(buf, "%02x%02x%02x%02x-"
        "%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
        p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
        p[8], p[9], p[10], p[11], p[12], p[13], p[14], p[15]);

    // Create register.mof:

    static const char REGISTER_FMT[] =
        "Instance of __Win32Provider as $P\n"
        "{\n"
        "    Name = \"%s\";\n"
        "    ClsId = \"{%s}\";\n"
        "};\n"
        "\n"
        "instance of __InstanceProviderRegistration\n"
        "{\n"
        "    Provider = $P;\n"
        "    SupportsPut = TRUE;\n"
        "    SupportsGet = TRUE;\n"
        "    SupportsDelete = TRUE;\n"
        "    SupportsEnumeration = TRUE;\n"
        "    QuerySupportLevels = { \"WQL:UnarySelect\" };\n"
        "};\n"
        "instance of __MethodProviderRegistration\n"
        "{\n"
        "    Provider = $P;\n"
        "};\n";

    fprintf(os, REGISTER_FMT, module_name, buf);

    printf("Created %s\n", fn);
}

#endif /* defined(CIMPLE_WINDOWS) */

static void gen_module(const char* module_name, int argc, char** argv)
{
    // Build provider info list.

    vector<const MOF_Class_Decl*> cds;

    for (int i = 0; i < argc; i++)
    {
        // Lookup class.

        const char* class_name = argv[i];
        const MOF_Class_Decl* cd = MOF_Class_Decl::find((char*)class_name);

        if (!cd)
            err("no such class in MOF repository: %s", class_name);

        cds.push_back(cd);
    }

    // Check force (-f) option.

    const char file_name[] = "module.cpp";

    // Open output file.

    FILE* os = fopen(file_name, "wb");

    if (!os)
        err("failed to open \"%s\"", file_name);

    // Generate warning block.

    gen_warning(os);

    // Generate the NOCHKSRC flag for pegasus chksrc program
    // The output code will have lines longer than 80 characters.
    fprintf(os,"/* NOCHKSRC */\n");

    // Includes:

    fprintf(os, "#include <cimple/cimple.h>\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        fprintf(os, "#include \"%s_Provider.h\"\n", cds[i]->name);
    }

    fprintf(os, "\n");

    // CIMPLE namespace:

    fprintf(os, "using namespace cimple;\n");
    fprintf(os, "\n");

    // Write proc() functions.

    for (size_t i = 0; i < cds.size(); i++)
        write_proc(os, cds[i]);

    // Module:

    fprintf(os, "CIMPLE_MODULE(%s_Module);\n", module_name);

    // Providers:

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
            fprintf(os, "CIMPLE_INDICATION_PROVIDER(%s_Provider);\n", cn);
        else if (mask & MOF_QT_ASSOCIATION)
            fprintf(os, "CIMPLE_ASSOCIATION_PROVIDER(%s_Provider);\n", cn);
        else
            fprintf(os, "CIMPLE_INSTANCE_PROVIDER(%s_Provider);\n", cn);
    }

    fprintf(os, "\n");

    // Generate Pegasus entry point.

    fprintf(os, "#ifdef CIMPLE_PEGASUS_MODULE\n");
    fprintf(os, "  CIMPLE_PEGASUS_PROVIDER_ENTRY_POINT;\n");
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate CMPI entry point.

    fprintf(os, "#ifdef CIMPLE_CMPI_MODULE\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
        {
            fprintf(os, 
                "  CIMPLE_CMPI_INDICATION_PROVIDER(%s_Provider);\n", cn);
            fprintf(os, 
                "  CIMPLE_CMPI_INDICATION_PROVIDER2(%s_Provider, %s);\n",
                cn, cn);
        }
        else if (mask & MOF_QT_ASSOCIATION)
        {
            fprintf(os, 
                "  CIMPLE_CMPI_ASSOCIATION_PROVIDER(%s_Provider);\n",
                cn);
            fprintf(os, 
                "  CIMPLE_CMPI_ASSOCIATION_PROVIDER2(%s_Provider, %s);\n",
                cn, cn);
        }
        else
        {
            fprintf(os, 
                "  CIMPLE_CMPI_INSTANCE_PROVIDER(%s_Provider);\n", cn);
            fprintf(os, 
                "  CIMPLE_CMPI_INSTANCE_PROVIDER2(%s_Provider, %s);\n", cn, cn);
        }
    }

    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate OpenWBEM entry point.

    fprintf(os, "#ifdef CIMPLE_OPENWBEM_MODULE\n");
    fprintf(os, "  CIMPLE_OPENWBEM_PROVIDER(%s_Module);\n", module_name);
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n\n");

    // Generate WMI entry point.

    /*
        #ifdef CIMPLE_WMI_MODULE
          // {23CB8761-914A-11cf-B705-00AA0062CBBB}
          DEFINE_GUID(CLSID_Gadget_Module,
            0x23cb8761, 0x914a,
            0x11cf, 0xb7, 0x5,
            0x0, 0xaa, 0x0, 0x62,
            0xcb, 0xbb);
          CIMPLE_WMI_PROVIDER_ENTRY_POINTS(CLSID_Gadget_Module)
        # define __CIMPLE_FOUND_ENTRY_POINT
        #endif
    */
    {
        fprintf(os, "#ifdef CIMPLE_WMI_MODULE\n");
        fprintf(os, "# include \"guid.h\"\n");
        fprintf(os, "  CIMPLE_WMI_PROVIDER_ENTRY_POINTS(CLSID_%s_Module)\n",
            module_name);
        fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
        fprintf(os, "#endif\n\n");
    }

    // Generate check for entry point.

    const char MESSAGE[] = 
        "No provider entry point found. Please define one of the following: "
        "CIMPLE_PEGASUS_MODULE, CIMPLE_CMPI_MODULE, CIMPLE_OPENWBEM_MODULE, "
        "CIMPLE_WMI_MODULE";

    fprintf(os, "#ifndef __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "# error \"%s\"\n", MESSAGE);
    fprintf(os, "#endif\n");

    printf("Created %s\n", file_name);

    fclose(os);
}

static void gen_module_file(const char* module_name, vector<string>& classes)
{
    // Build provider info list.

    vector<const MOF_Class_Decl*> cds;

    for (int i = 0; i < classes.size(); i++)
    {
        // Lookup class.

        const char* class_name = classes[i].c_str();
        const MOF_Class_Decl* cd = MOF_Class_Decl::find((char*)class_name);

        if (!cd)
            err("no such class in MOF repository: %s", class_name);

        cds.push_back(cd);
    }

    // Open output file.

    const char file_name[] = "module.cpp";

    FILE* os = fopen(file_name, "wb");

    if (!os)
        err("failed to open output file \"%s\"", file_name);

    // Generate warning block.

    gen_warning(os);

    // Generate the NOCHKSRC flag for pegasus chksrc program
    // The output code will have lines longer than 80 characters.
    fprintf(os,"/* NOCHKSRC */\n");

    // Includes:

    fprintf(os, "#include <cimple/cimple.h>\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        fprintf(os, "#include \"%s_Provider.h\"\n", cds[i]->name);
    }

    fprintf(os, "\n");

    // CIMPLE namespace:

    fprintf(os, "using namespace cimple;\n");
    fprintf(os, "\n");

    // Write proc() functions.

    for (size_t i = 0; i < cds.size(); i++)
        write_proc(os, cds[i]);

    // Module:

    fprintf(os, "CIMPLE_MODULE(%s_Module);\n", module_name);

    // Providers:

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
            fprintf(os, "CIMPLE_INDICATION_PROVIDER(%s_Provider);\n", cn);
        else if (mask & MOF_QT_ASSOCIATION)
            fprintf(os, "CIMPLE_ASSOCIATION_PROVIDER(%s_Provider);\n", cn);
        else
            fprintf(os, "CIMPLE_INSTANCE_PROVIDER(%s_Provider);\n", cn);
    }

    fprintf(os, "\n");

    // Generate Pegasus entry point.

    fprintf(os, "#ifdef CIMPLE_PEGASUS_MODULE\n");
    fprintf(os, "  CIMPLE_PEGASUS_PROVIDER_ENTRY_POINT;\n");
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate CMPI entry point.

    fprintf(os, "#ifdef CIMPLE_CMPI_MODULE\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
        {
            fprintf(os, 
                "  CIMPLE_CMPI_INDICATION_PROVIDER(%s_Provider);\n", cn);
            fprintf(os, 
                "  CIMPLE_CMPI_INDICATION_PROVIDER2(%s_Provider, %s);\n",
                cn, cn);
        }
        else if (mask & MOF_QT_ASSOCIATION)
        {
            fprintf(os, 
                "  CIMPLE_CMPI_ASSOCIATION_PROVIDER(%s_Provider);\n",
                cn);
            fprintf(os, 
                "  CIMPLE_CMPI_ASSOCIATION_PROVIDER2(%s_Provider, %s);\n",
                cn, cn);
        }
        else
        {
            fprintf(os, 
                "  CIMPLE_CMPI_INSTANCE_PROVIDER(%s_Provider);\n", cn);
            fprintf(os, 
                "  CIMPLE_CMPI_INSTANCE_PROVIDER2(%s_Provider, %s);\n", cn, cn);
        }
    }

    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate OpenWBEM entry point.

    fprintf(os, "#ifdef CIMPLE_OPENWBEM_MODULE\n");
    fprintf(os, "  CIMPLE_OPENWBEM_PROVIDER(%s_Module);\n", module_name);
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n\n");

    // Generate WMI entry point.

    /*
        #ifdef CIMPLE_WMI_MODULE
          // {23CB8761-914A-11cf-B705-00AA0062CBBB}
          DEFINE_GUID(CLSID_Gadget_Module,
            0x23cb8761, 0x914a,
            0x11cf, 0xb7, 0x5,
            0x0, 0xaa, 0x0, 0x62,
            0xcb, 0xbb);
          CIMPLE_WMI_PROVIDER_ENTRY_POINTS(CLSID_Gadget_Module)
        # define __CIMPLE_FOUND_ENTRY_POINT
        #endif
    */
    {
        fprintf(os, "#ifdef CIMPLE_WMI_MODULE\n");
        fprintf(os, "# include \"guid.h\"\n");
        fprintf(os, "  CIMPLE_WMI_PROVIDER_ENTRY_POINTS(CLSID_%s_Module)\n",
            module_name);
        fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
        fprintf(os, "#endif\n\n");
    }

    // Generate check for entry point.

    const char MESSAGE[] = 
        "No provider entry point found. Please define one of the following: "
        "CIMPLE_PEGASUS_MODULE, CIMPLE_CMPI_MODULE, CIMPLE_OPENWBEM_MODULE, "
        "CIMPLE_WMI_MODULE";

    fprintf(os, "#ifndef __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "# error \"%s\"\n", MESSAGE);
    fprintf(os, "#endif\n");

    printf("Created %s\n", file_name);

    fclose(os);
}

int main(int argc, char** argv)
{
    const char* arg0 = argv[0];

    vector<string> mof_files;

    // Check options:

    int opt;

    while ((opt = getopt(argc, argv, "I:M:f:F:hV")) != -1)
    {
        switch (opt)
        {
            case 'I':
            {
                if (!optarg)
                {
                    err("missing argument on -I option");
                    exit(1);
                }

                if (MOF_num_include_paths == MAX_INCLUDES)
                {
                    err("too many -I options");
                    exit(1);
                }

                MOF_include_paths[MOF_num_include_paths++] = optarg;
                break;
            }

            case 'M':
            {
                if (!optarg)
                {
                    err("missing argument on -M option");
                    exit(1);
                }

                mof_files.push_back(optarg);
                break;
            }
            // because we had to sue the capitol form for the genprov
            // we claim it for all the others also.
            case 'f':
            case 'F':
			 {
                if (!optarg)
                {
                    err("missing argument on -f or -F option");
                    exit(1);
                }

                class_list_file = optarg;
                break;
			}
            case 'h':
            {
                fprintf(stderr, (char*)USAGE, arg0);
                exit(0);
            }

            case 'V':
            {
                printf("%s\n", CIMPLE_VERSION_STRING);
                exit(0);
            }

            default:
                err("unknown option: %c", opt);
                break;
        }
    }

    // Check usage.

    //argc -= optind;
    //argv += optind;

    if (argc < 2)
    {
        fprintf(stderr, "Error: Module Name argument required\n");
        fprintf(stderr,"%s %s",(char*)USAGE, arg0);
        exit(1);
    }

     if (optind == argc && class_list_file.size() == 0)
    {
        fprintf(stderr, "Error: Class list information required\n");
        fprintf(stderr,"%s %s",(char*)USAGE, arg0);
        exit(1);
    }

    // generate the class list from a combination of the command line input
    // and any defined class list file

	vector<string> classes;

    if (class_list_file.size())
        load_class_list_file(classes, class_list_file);

    // Generate classes list from command line starting after
    // module name parameter

    for (int i = optind + 1; i < argc; i++)
        append_unique(classes, argv[i]);
		
    // Load repository. 

    load_repository(mof_files);

    // Generate module file.

    //// remove this gen_module_file(argv[0], argc - 1, argv + 1);
	
	gen_module_file(argv[0], classes);

    // Generate guid.h file.

#if defined(CIMPLE_WINDOWS)
    {
        cimple::UUID uuid;
        cimple::create_uuid(uuid);

        gen_guid(argv[0], uuid);
        gen_register(argv[0], uuid);
    }
#endif /* defined(CIMPLE_WINDOWS) */

    // Generate register.mof.

    return 0;
}
