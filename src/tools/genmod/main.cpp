#include <cimple/config.h>
#include <cassert>
#include <getopt.h>
#include <cstdlib>
#include <cstring>
#include <cstdio>
#include <string>
#include <unistd.h>
#include <util/util.h>
#include <tools/gencommon/gencommon.h>
#include <MOF_Parser.h>
#include <vector>
#include <string>
#include "usage.h"

using namespace std;
bool cmpi_opt = false;
bool pegasus_opt = false;

void gen_comment_line(FILE* os, size_t n)
{
    n -= 2;
    fprintf(os, "//");

    for (size_t i = 0; i < n; i++)
        fputc('=', os);

    fputc('\n', os);
}

void gen_warning(FILE* os)
{
    gen_comment_line(os, 80);
    fprintf(os, "//\n");
    fprintf(os, "// PLEASE DO NOT EDIT; "
        "THIS FILE WAS AUTOMATICALLY GENERATED BY GENMOD %s\n", 
        CIMPLE_VERSION_STRING);
    fprintf(os, "//\n");
    gen_comment_line(os, 80);
    fputc('\n', os);
}

static const char prefix[] = "\
static int __cimple_%s_Provider_proc(\n\
    const Registration* registration,\n\
    int operation,\n\
    void* arg0,\n\
    void* arg1,\n\
    void* arg2,\n\
    void* arg3,\n\
    void* arg4,\n\
    void* arg5,\n\
    void* arg6,\n\
    void* arg7)\n\
{\n\
    typedef %s Class;\n\
    typedef %s_Provider Provider;\n\
\n\
    if (operation != OPERATION_INVOKE_METHOD)\n\
        return %s_Provider_Proc_T<Provider>::proc(registration,\n\
            operation, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n\
\n\
    Provider* provider = (Provider*)arg0;\n\
    const Class* self = (const Class*)arg1;\n\
    const char* meth_name = ((Instance*)arg2)->meta_class->name;\n\
\n";

static const char suffix[] = "\
    return -1;\n\
}\n\
\n";

void write_skeleton(
    FILE* os,
    const char* class_name, 
    const MOF_Method_Decl* meth)
{
    fprintf(os, "    if (strcasecmp(meth_name, \"%s\") == 0)\n", 
        meth->name);
    fprintf(os, "    {\n");

    fprintf(os, "        typedef %s_%s_method Method;\n", 
        class_name, meth->name);

    fprintf(os, "        Method* method = (Method*)arg2;\n");

    fprintf(os, "        return provider->%s(\n", meth->name);

    if (!(meth->qual_mask & MOF_QT_STATIC))
        fprintf(os, "            self,\n");

    for (MOF_Parameter* p = meth->parameters; p; p = (MOF_Parameter*)p->next)
    {
        fprintf(os, "            method->%s", p->name);
        fprintf(os, ",\n");
    }

    fprintf(os, "            method->return_value);\n");

    fprintf(os, "    }\n\n");
}

static void write_proc(FILE* os, const MOF_Class_Decl* cd)
{
    // Write prefix:

    const char* cn = cd->name;
    const char* pt;

    if (cd->qual_mask & MOF_QT_ASSOCIATION)
        pt = "Association";
    else if (cd->qual_mask & MOF_QT_INDICATION)
        pt = "Indication";
    else
        pt = "Instance";

    fprintf(os, prefix, cn, cn, cn, pt);

    // Write methods:

    MOF_Feature_Info* p = cd->all_features;

    for (; p; p = (MOF_Feature_Info*)p->next)
    {
        MOF_Method_Decl* meth = dynamic_cast<MOF_Method_Decl*>(p->feature);

        if (!meth)
            continue;

        write_skeleton(os, cn, meth);
    }

    // Write suffix:

    fprintf(os, suffix);
}

static void gen_module(const char* module_name, int argc, char** argv)
{
    // Build provider info list.

    vector<const MOF_Class_Decl*> cds;

    for (int i = 0; i < argc; i++)
    {
        // Lookup class.

        const char* class_name = argv[i];
        const MOF_Class_Decl* cd = MOF_Class_Decl::find((char*)class_name);

        if (!cd)
            err("no such class in MOF repository: %s", class_name);

        cds.push_back(cd);
    }

    // Check force (-f) option.

    const char file_name[] = "module.cpp";

    // Open output file.

    FILE* os = fopen(file_name, "wb");

    if (!os)
        err("failed to open \"%s\"", file_name);

    // Generate warning block.

    gen_warning(os);

    // Includes:

    fprintf(os, "#include <cimple/cimple.h>\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        fprintf(os, "#include \"%s_Provider.h\"\n", cds[i]->name);
    }

    fprintf(os, "\n");

    // CIMPLE namespace:

    fprintf(os, "using namespace cimple;\n");
    fprintf(os, "\n");

    // Write proc() functions.

    for (size_t i = 0; i < cds.size(); i++)
        write_proc(os, cds[i]);

    // Module:

    fprintf(os, "CIMPLE_MODULE(%s_Module);\n", module_name);

    // Providers:

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
            fprintf(os, "CIMPLE_INDICATION_PROVIDER(%s_Provider);\n", cn);
        else if (mask & MOF_QT_ASSOCIATION)
            fprintf(os, "CIMPLE_ASSOCIATION_PROVIDER(%s_Provider);\n", cn);
        else
            fprintf(os, "CIMPLE_INSTANCE_PROVIDER(%s_Provider);\n", cn);
    }

    fprintf(os, "\n");

    // Generate Pegasus entry point.

    fprintf(os, "#ifdef CIMPLE_PEGASUS_MODULE\n");
    fprintf(os, "  CIMPLE_PEGASUS_PROVIDER_ENTRY_POINT;\n");
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate CMPI entry point.

    fprintf(os, "#ifdef CIMPLE_CMPI_MODULE\n");

    for (size_t i = 0; i < cds.size(); i++)
    {
        const char* cn = cds[i]->name;
        int mask = cds[i]->qual_mask;

        if (mask & MOF_QT_INDICATION)
        {
            fprintf(os, "  CIMPLE_CMPI_INDICATION_PROVIDER(%s_Provider);\n",
                cn);
        }
        else if (mask & MOF_QT_ASSOCIATION)
        {
            fprintf(os, "  CIMPLE_CMPI_ASSOCIATION_PROVIDER(%s_Provider);\n",
                cn);
        }
        else
        {
            fprintf(os, "  CIMPLE_CMPI_INSTANCE_PROVIDER(%s_Provider);\n", cn);
        }
    }

    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");
    fprintf(os, "\n");

    // Generate OpenWBEM entry point.

    fprintf(os, "#ifdef CIMPLE_OPENWBEM_MODULE\n");
    fprintf(os, "  CIMPLE_OPENWBEM_PROVIDER(%s_Module);\n", module_name);
    fprintf(os, "# define __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "#endif\n");

    const char MESSAGE[] = 
        "No provider entry point found. Please define one of the following: "
        "CIMPLE_PEGASUS_MODULE, CIMPLE_CMPI_MODULE, CIMPLE_OPENWBEM_MODULE";

    fprintf(os, "\n");
    fprintf(os, "#ifndef __CIMPLE_FOUND_ENTRY_POINT\n");
    fprintf(os, "# error \"%s\"\n", MESSAGE);
    fprintf(os, "#endif\n");

    printf("Created %s\n", file_name);
    printf("\n");

    fclose(os);
}

int main(int argc, char** argv)
{
    const char* arg0 = argv[0];

    vector<string> mof_files;

    // Check options:

    int opt;

    while ((opt = getopt(argc, argv, "I:M:hV")) != -1)
    {
        switch (opt)
        {
            case 'I':
            {
                if (!optarg)
                {
                    err("missing argument on -I option");
                    exit(1);
                }

                if (MOF_num_include_paths == MAX_INCLUDES)
                {
                    err("too many -I options");
                    exit(1);
                }

                MOF_include_paths[MOF_num_include_paths++] = optarg;
                break;
            }

            case 'M':
            {
                if (!optarg)
                {
                    err("missing argument on -M option");
                    exit(1);
                }

                mof_files.push_back(optarg);
                break;
            } 

            case 'h':
            {
                fprintf(stderr, (char*)USAGE, arg0);
                exit(0);
            }

            case 'V':
            {
                printf("%s\n", CIMPLE_VERSION_STRING);
                exit(0);
            }

            default:
                err("unknown option: %c", opt);
                break;
        }
    }

    // Check usage.

    argc -= optind;
    argv += optind;

    if (argc < 2)
    {
        fprintf(stderr, (char*)USAGE, arg0);
        exit(1);
    }

    // Load repository. 

    load_repository(mof_files);

    // Generate module file.

    gen_module(argv[0], argc - 1, argv + 1);

    return 0;
}

CIMPLE_ID("$Header: /home/cvs/cimple/src/tools/genmod/main.cpp,v 1.9 2007/06/26 20:48:17 mbrasher-public Exp $");
