//==============================================================================
//
// PLEASE DO NOT EDIT THIS FILE; IT WAS AUTOMATICALLY GENERATED BY GENHND.
//
//==============================================================================

#ifndef _cimple_Assoc1_Hnd
#define _cimple_Assoc1_Hnd

#include <cimple/cimple.h>
#include "Assoc1.h"
#include "Class1_Hnd.h"

CIMPLE_NAMESPACE_BEGIN

class Assoc1_Ref : public Instance_Ref
{
public:
    typedef Assoc1 Class;
    Assoc1_Ref();
    Assoc1_Ref(const Assoc1_Ref& x);
    Assoc1_Ref(Assoc1* inst);
    explicit Assoc1_Ref(const Instance_Ref& x);
    ~Assoc1_Ref();
    Assoc1_Ref& operator=(const Assoc1_Ref& x);
    static bool is_a(const Instance_Ref& x);

    // Left:
    Class1_Ref Left_value() const;
    void Left_value(const Class1_Ref& x);
    bool Left_null() const;
    void Left_clear();

    // Right:
    Class1_Ref Right_value() const;
    void Right_value(const Class1_Ref& x);
    bool Right_null() const;
    void Right_clear();

protected:
    Assoc1_Ref(const Meta_Class* mc);
    Assoc1_Ref(const Meta_Class* mc, const Instance_Ref& x);
};

class Assoc1_Hnd : public Instance_Hnd
{
public:
    typedef Assoc1 Class;
    Assoc1_Hnd();
    Assoc1_Hnd(const Assoc1_Hnd& x);
    Assoc1_Hnd(Assoc1* inst);
    explicit Assoc1_Hnd(const Instance_Hnd& x);
    ~Assoc1_Hnd();
    Assoc1_Hnd& operator=(const Assoc1_Hnd& x);
    static bool is_a(const Instance_Hnd& x);
    Assoc1_Ref reference() const;

    // Left:
    Class1_Ref Left_value() const;
    void Left_value(const Class1_Ref& x);
    bool Left_null() const;
    void Left_clear();

    // Right:
    Class1_Ref Right_value() const;
    void Right_value(const Class1_Ref& x);
    bool Right_null() const;
    void Right_clear();

protected:
    Assoc1_Hnd(const Meta_Class* mc);
    Assoc1_Hnd(const Meta_Class* mc, const Instance_Hnd& x);
};

inline Assoc1_Ref::Assoc1_Ref() :
    Instance_Ref(&Assoc1::static_meta_class)
{
}

inline Assoc1_Ref::Assoc1_Ref(const Assoc1_Ref& x) :
    Instance_Ref(x)
{
}

inline Assoc1_Ref::Assoc1_Ref(Assoc1* inst) :
    Instance_Ref((Instance*)inst)
{
}

inline Assoc1_Ref::Assoc1_Ref(const Instance_Ref& x) : 
    Instance_Ref(&Assoc1::static_meta_class, x)
{
}

inline Assoc1_Ref::Assoc1_Ref(const Meta_Class* mc) : Instance_Ref(mc)
{
}

inline Assoc1_Ref::Assoc1_Ref(const Meta_Class* mc, const Instance_Ref& x) : Instance_Ref(mc, x)
{
}

inline Assoc1_Ref::~Assoc1_Ref()
{
}

inline Assoc1_Ref& Assoc1_Ref::operator=(const Assoc1_Ref& x)
{
    Instance_Ref::operator=(x);
    return *this;
}

inline bool Assoc1_Ref::is_a(const Instance_Ref& x)
{
    return is_subclass(&Assoc1::static_meta_class, x.meta_class());
}

inline Class1_Ref Assoc1_Ref::Left_value() const
{
    if (!((Class*)_inst)->Left)
        _throw_null_access("Left");
    ref(((Class*)_inst)->Left);
    return Class1_Ref(((Class*)_inst)->Left);
}

inline void Assoc1_Ref::Left_value(const Class1_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Left);
    ref(((Class*)_inst)->Left = (Class1*)x.instance());
}

inline bool Assoc1_Ref::Left_null() const
{
    return ((Class*)_inst)->Left == 0;
}

inline void Assoc1_Ref::Left_clear()
{
    _cow();
    unref(((Class*)_inst)->Left);
    ((Class*)_inst)->Left = 0;
}

inline Class1_Ref Assoc1_Ref::Right_value() const
{
    if (!((Class*)_inst)->Right)
        _throw_null_access("Right");
    ref(((Class*)_inst)->Right);
    return Class1_Ref(((Class*)_inst)->Right);
}

inline void Assoc1_Ref::Right_value(const Class1_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Right);
    ref(((Class*)_inst)->Right = (Class1*)x.instance());
}

inline bool Assoc1_Ref::Right_null() const
{
    return ((Class*)_inst)->Right == 0;
}

inline void Assoc1_Ref::Right_clear()
{
    _cow();
    unref(((Class*)_inst)->Right);
    ((Class*)_inst)->Right = 0;
}

inline Assoc1_Hnd::Assoc1_Hnd() :
    Instance_Hnd(&Assoc1::static_meta_class)
{
}

inline Assoc1_Hnd::Assoc1_Hnd(const Assoc1_Hnd& x) :
    Instance_Hnd(x)
{
}

inline Assoc1_Hnd::Assoc1_Hnd(Assoc1* inst) :
    Instance_Hnd((Instance*)inst)
{
}

inline Assoc1_Hnd::Assoc1_Hnd(const Instance_Hnd& x) : 
    Instance_Hnd(&Assoc1::static_meta_class, x)
{
}

inline Assoc1_Hnd::Assoc1_Hnd(const Meta_Class* mc) : Instance_Hnd(mc)
{
}

inline Assoc1_Hnd::Assoc1_Hnd(const Meta_Class* mc, const Instance_Hnd& x) : Instance_Hnd(mc, x)
{
}

inline Assoc1_Hnd::~Assoc1_Hnd()
{
}

inline Assoc1_Hnd& Assoc1_Hnd::operator=(const Assoc1_Hnd& x)
{
    Instance_Hnd::operator=(x);
    return *this;
}

inline bool Assoc1_Hnd::is_a(const Instance_Hnd& x)
{
    return is_subclass(&Assoc1::static_meta_class, x.meta_class());
}

inline Assoc1_Ref Assoc1_Hnd::reference() const
{
    return Assoc1_Ref((Assoc1*)key_clone(_inst));
}

inline Class1_Ref Assoc1_Hnd::Left_value() const
{
    if (!((Class*)_inst)->Left)
        _throw_null_access("Left");
    ref(((Class*)_inst)->Left);
    return Class1_Ref(((Class*)_inst)->Left);
}

inline void Assoc1_Hnd::Left_value(const Class1_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Left);
    ref(((Class*)_inst)->Left = (Class1*)x.instance());
}

inline bool Assoc1_Hnd::Left_null() const
{
    return ((Class*)_inst)->Left == 0;
}

inline void Assoc1_Hnd::Left_clear()
{
    _cow();
    unref(((Class*)_inst)->Left);
    ((Class*)_inst)->Left = 0;
}

inline Class1_Ref Assoc1_Hnd::Right_value() const
{
    if (!((Class*)_inst)->Right)
        _throw_null_access("Right");
    ref(((Class*)_inst)->Right);
    return Class1_Ref(((Class*)_inst)->Right);
}

inline void Assoc1_Hnd::Right_value(const Class1_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Right);
    ref(((Class*)_inst)->Right = (Class1*)x.instance());
}

inline bool Assoc1_Hnd::Right_null() const
{
    return ((Class*)_inst)->Right == 0;
}

inline void Assoc1_Hnd::Right_clear()
{
    _cow();
    unref(((Class*)_inst)->Right);
    ((Class*)_inst)->Right = 0;
}

CIMPLE_NAMESPACE_END

#endif /* _cimple_Assoc1_Hnd_h */
