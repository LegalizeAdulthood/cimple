//==============================================================================
//
// PLEASE DO NOT EDIT THIS FILE; IT WAS AUTOMATICALLY GENERATED BY GENHND.
//
//==============================================================================

#ifndef _cimple_Whole_Hnd
#define _cimple_Whole_Hnd

#include <cimple/cimple.h>
#include "Whole.h"
#include "Part_Hnd.h"

CIMPLE_NAMESPACE_BEGIN

class Whole_Ref : public Instance_Ref
{
public:
    typedef Whole Class;
    Whole_Ref();
    Whole_Ref(const Whole_Ref& x);
    Whole_Ref(Whole* inst);
    explicit Whole_Ref(const Instance_Ref& x);
    ~Whole_Ref();
    Whole_Ref& operator=(const Whole_Ref& x);
    static bool is_a(const Instance_Ref& x);

    // Key:
    const uint32& Key_value() const;
    void Key_value(const uint32& x);
    bool Key_null() const;
    void Key_clear();

protected:
    Whole_Ref(const Meta_Class* mc);
    Whole_Ref(const Meta_Class* mc, const Instance_Ref& x);
};

class Whole_Hnd : public Instance_Hnd
{
public:
    typedef Whole Class;
    Whole_Hnd();
    Whole_Hnd(const Whole_Hnd& x);
    Whole_Hnd(Whole* inst);
    explicit Whole_Hnd(const Instance_Hnd& x);
    ~Whole_Hnd();
    Whole_Hnd& operator=(const Whole_Hnd& x);
    static bool is_a(const Instance_Hnd& x);
    Whole_Ref reference() const;

    // Key:
    const uint32& Key_value() const;
    void Key_value(const uint32& x);
    bool Key_null() const;
    void Key_clear();

    // emb:
    Part_Hnd emb_value() const;
    void emb_value(const Part_Hnd& x);
    bool emb_null() const;
    void emb_clear();

protected:
    Whole_Hnd(const Meta_Class* mc);
    Whole_Hnd(const Meta_Class* mc, const Instance_Hnd& x);
};

inline Whole_Ref::Whole_Ref() :
    Instance_Ref(&Whole::static_meta_class)
{
}

inline Whole_Ref::Whole_Ref(const Whole_Ref& x) :
    Instance_Ref(x)
{
}

inline Whole_Ref::Whole_Ref(Whole* inst) :
    Instance_Ref((Instance*)inst)
{
}

inline Whole_Ref::Whole_Ref(const Instance_Ref& x) : 
    Instance_Ref(&Whole::static_meta_class, x)
{
}

inline Whole_Ref::Whole_Ref(const Meta_Class* mc) : Instance_Ref(mc)
{
}

inline Whole_Ref::Whole_Ref(const Meta_Class* mc, const Instance_Ref& x) : Instance_Ref(mc, x)
{
}

inline Whole_Ref::~Whole_Ref()
{
}

inline Whole_Ref& Whole_Ref::operator=(const Whole_Ref& x)
{
    Instance_Ref::operator=(x);
    return *this;
}

inline bool Whole_Ref::is_a(const Instance_Ref& x)
{
    return is_subclass(&Whole::static_meta_class, x.meta_class());
}

inline const uint32& Whole_Ref::Key_value() const
{
    if (((Class*)_inst)->Key.null)
        _throw_null_access("Key");
   return ((Class*)_inst)->Key.value;
}

inline void Whole_Ref::Key_value(const uint32& x)
{
    _cow();
   ((Class*)_inst)->Key.value = x;
   ((Class*)_inst)->Key.null = false;
}

inline bool Whole_Ref::Key_null() const
{
   return ((Class*)_inst)->Key.null;
}

inline void Whole_Ref::Key_clear()
{
    _cow();
    __clear(((Class*)_inst)->Key.value);
    ((Class*)_inst)->Key.null = true;;
}

inline Whole_Hnd::Whole_Hnd() :
    Instance_Hnd(&Whole::static_meta_class)
{
}

inline Whole_Hnd::Whole_Hnd(const Whole_Hnd& x) :
    Instance_Hnd(x)
{
}

inline Whole_Hnd::Whole_Hnd(Whole* inst) :
    Instance_Hnd((Instance*)inst)
{
}

inline Whole_Hnd::Whole_Hnd(const Instance_Hnd& x) : 
    Instance_Hnd(&Whole::static_meta_class, x)
{
}

inline Whole_Hnd::Whole_Hnd(const Meta_Class* mc) : Instance_Hnd(mc)
{
}

inline Whole_Hnd::Whole_Hnd(const Meta_Class* mc, const Instance_Hnd& x) : Instance_Hnd(mc, x)
{
}

inline Whole_Hnd::~Whole_Hnd()
{
}

inline Whole_Hnd& Whole_Hnd::operator=(const Whole_Hnd& x)
{
    Instance_Hnd::operator=(x);
    return *this;
}

inline bool Whole_Hnd::is_a(const Instance_Hnd& x)
{
    return is_subclass(&Whole::static_meta_class, x.meta_class());
}

inline Whole_Ref Whole_Hnd::reference() const
{
    return Whole_Ref((Whole*)key_clone(_inst));
}

inline const uint32& Whole_Hnd::Key_value() const
{
    if (((Class*)_inst)->Key.null)
        _throw_null_access("Key");
   return ((Class*)_inst)->Key.value;
}

inline void Whole_Hnd::Key_value(const uint32& x)
{
    _cow();
   ((Class*)_inst)->Key.value = x;
   ((Class*)_inst)->Key.null = false;
}

inline bool Whole_Hnd::Key_null() const
{
   return ((Class*)_inst)->Key.null;
}

inline void Whole_Hnd::Key_clear()
{
    _cow();
    __clear(((Class*)_inst)->Key.value);
    ((Class*)_inst)->Key.null = true;;
}

inline Part_Hnd Whole_Hnd::emb_value() const
{
    if (!((Class*)_inst)->emb)
        _throw_null_access("emb");
    ref(((Class*)_inst)->emb);
    return Part_Hnd(((Class*)_inst)->emb);
}

inline void Whole_Hnd::emb_value(const Part_Hnd& x)
{
    _cow();
    unref(((Class*)_inst)->emb);
    ref(((Class*)_inst)->emb = (Part*)x.instance());
}

inline bool Whole_Hnd::emb_null() const
{
    return ((Class*)_inst)->emb == 0;
}

inline void Whole_Hnd::emb_clear()
{
    _cow();
    unref(((Class*)_inst)->emb);
    ((Class*)_inst)->emb = 0;
}

CIMPLE_NAMESPACE_END

#endif /* _cimple_Whole_Hnd_h */
