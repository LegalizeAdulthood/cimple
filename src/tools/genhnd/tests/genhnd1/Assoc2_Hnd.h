//==============================================================================
//
// PLEASE DO NOT EDIT THIS FILE; IT WAS AUTOMATICALLY GENERATED BY GENHND.
//
//==============================================================================

#ifndef _cimple_Assoc2_Hnd
#define _cimple_Assoc2_Hnd

#include <cimple/cimple.h>
#include "Assoc2.h"
#include "Assoc1_Hnd.h"
#include "Class2_Hnd.h"

CIMPLE_NAMESPACE_BEGIN

class Assoc2_Ref : public Assoc1_Ref
{
public:
    typedef Assoc2 Class;
    Assoc2_Ref();
    Assoc2_Ref(const Assoc2_Ref& x);
    Assoc2_Ref(Assoc2* inst);
    explicit Assoc2_Ref(const Instance_Ref& x);
    ~Assoc2_Ref();
    Assoc2_Ref& operator=(const Assoc2_Ref& x);
    static bool is_a(const Instance_Ref& x);

    // Left:
    Class2_Ref Left_value() const;
    void Left_value(const Class2_Ref& x);
    bool Left_null() const;
    void Left_clear();

    // Right:
    Class2_Ref Right_value() const;
    void Right_value(const Class2_Ref& x);
    bool Right_null() const;
    void Right_clear();

protected:
    Assoc2_Ref(const Meta_Class* mc);
    Assoc2_Ref(const Meta_Class* mc, const Instance_Ref& x);
};

class Assoc2_Hnd : public Assoc1_Hnd
{
public:
    typedef Assoc2 Class;
    Assoc2_Hnd();
    Assoc2_Hnd(const Assoc2_Hnd& x);
    Assoc2_Hnd(Assoc2* inst);
    explicit Assoc2_Hnd(const Instance_Hnd& x);
    ~Assoc2_Hnd();
    Assoc2_Hnd& operator=(const Assoc2_Hnd& x);
    static bool is_a(const Instance_Hnd& x);
    Assoc2_Ref reference() const;

    // Left:
    Class2_Ref Left_value() const;
    void Left_value(const Class2_Ref& x);
    bool Left_null() const;
    void Left_clear();

    // Right:
    Class2_Ref Right_value() const;
    void Right_value(const Class2_Ref& x);
    bool Right_null() const;
    void Right_clear();

protected:
    Assoc2_Hnd(const Meta_Class* mc);
    Assoc2_Hnd(const Meta_Class* mc, const Instance_Hnd& x);
};

inline Assoc2_Ref::Assoc2_Ref() :
    Assoc1_Ref(&Assoc2::static_meta_class)
{
}

inline Assoc2_Ref::Assoc2_Ref(const Assoc2_Ref& x) :
    Assoc1_Ref(x)
{
}

inline Assoc2_Ref::Assoc2_Ref(Assoc2* inst) :
    Assoc1_Ref((Assoc1*)inst)
{
}

inline Assoc2_Ref::Assoc2_Ref(const Instance_Ref& x) : 
    Assoc1_Ref(&Assoc2::static_meta_class, x)
{
}

inline Assoc2_Ref::Assoc2_Ref(const Meta_Class* mc) : Assoc1_Ref(mc)
{
}

inline Assoc2_Ref::Assoc2_Ref(const Meta_Class* mc, const Instance_Ref& x) : Assoc1_Ref(mc, x)
{
}

inline Assoc2_Ref::~Assoc2_Ref()
{
}

inline Assoc2_Ref& Assoc2_Ref::operator=(const Assoc2_Ref& x)
{
    Assoc1_Ref::operator=(x);
    return *this;
}

inline bool Assoc2_Ref::is_a(const Instance_Ref& x)
{
    return is_subclass(&Assoc2::static_meta_class, x.meta_class());
}

inline Class2_Ref Assoc2_Ref::Left_value() const
{
    if (!((Class*)_inst)->Left)
        _throw_null_access("Left");
    ref(((Class*)_inst)->Left);
    return Class2_Ref(((Class*)_inst)->Left);
}

inline void Assoc2_Ref::Left_value(const Class2_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Left);
    ref(((Class*)_inst)->Left = (Class2*)x.instance());
}

inline bool Assoc2_Ref::Left_null() const
{
    return ((Class*)_inst)->Left == 0;
}

inline void Assoc2_Ref::Left_clear()
{
    _cow();
    unref(((Class*)_inst)->Left);
    ((Class*)_inst)->Left = 0;
}

inline Class2_Ref Assoc2_Ref::Right_value() const
{
    if (!((Class*)_inst)->Right)
        _throw_null_access("Right");
    ref(((Class*)_inst)->Right);
    return Class2_Ref(((Class*)_inst)->Right);
}

inline void Assoc2_Ref::Right_value(const Class2_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Right);
    ref(((Class*)_inst)->Right = (Class2*)x.instance());
}

inline bool Assoc2_Ref::Right_null() const
{
    return ((Class*)_inst)->Right == 0;
}

inline void Assoc2_Ref::Right_clear()
{
    _cow();
    unref(((Class*)_inst)->Right);
    ((Class*)_inst)->Right = 0;
}

inline Assoc2_Hnd::Assoc2_Hnd() :
    Assoc1_Hnd(&Assoc2::static_meta_class)
{
}

inline Assoc2_Hnd::Assoc2_Hnd(const Assoc2_Hnd& x) :
    Assoc1_Hnd(x)
{
}

inline Assoc2_Hnd::Assoc2_Hnd(Assoc2* inst) :
    Assoc1_Hnd((Assoc1*)inst)
{
}

inline Assoc2_Hnd::Assoc2_Hnd(const Instance_Hnd& x) : 
    Assoc1_Hnd(&Assoc2::static_meta_class, x)
{
}

inline Assoc2_Hnd::Assoc2_Hnd(const Meta_Class* mc) : Assoc1_Hnd(mc)
{
}

inline Assoc2_Hnd::Assoc2_Hnd(const Meta_Class* mc, const Instance_Hnd& x) : Assoc1_Hnd(mc, x)
{
}

inline Assoc2_Hnd::~Assoc2_Hnd()
{
}

inline Assoc2_Hnd& Assoc2_Hnd::operator=(const Assoc2_Hnd& x)
{
    Assoc1_Hnd::operator=(x);
    return *this;
}

inline bool Assoc2_Hnd::is_a(const Instance_Hnd& x)
{
    return is_subclass(&Assoc2::static_meta_class, x.meta_class());
}

inline Assoc2_Ref Assoc2_Hnd::reference() const
{
    return Assoc2_Ref((Assoc2*)key_clone(_inst));
}

inline Class2_Ref Assoc2_Hnd::Left_value() const
{
    if (!((Class*)_inst)->Left)
        _throw_null_access("Left");
    ref(((Class*)_inst)->Left);
    return Class2_Ref(((Class*)_inst)->Left);
}

inline void Assoc2_Hnd::Left_value(const Class2_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Left);
    ref(((Class*)_inst)->Left = (Class2*)x.instance());
}

inline bool Assoc2_Hnd::Left_null() const
{
    return ((Class*)_inst)->Left == 0;
}

inline void Assoc2_Hnd::Left_clear()
{
    _cow();
    unref(((Class*)_inst)->Left);
    ((Class*)_inst)->Left = 0;
}

inline Class2_Ref Assoc2_Hnd::Right_value() const
{
    if (!((Class*)_inst)->Right)
        _throw_null_access("Right");
    ref(((Class*)_inst)->Right);
    return Class2_Ref(((Class*)_inst)->Right);
}

inline void Assoc2_Hnd::Right_value(const Class2_Ref& x)
{
    _cow();
    unref(((Class*)_inst)->Right);
    ref(((Class*)_inst)->Right = (Class2*)x.instance());
}

inline bool Assoc2_Hnd::Right_null() const
{
    return ((Class*)_inst)->Right == 0;
}

inline void Assoc2_Hnd::Right_clear()
{
    _cow();
    unref(((Class*)_inst)->Right);
    ((Class*)_inst)->Right = 0;
}

CIMPLE_NAMESPACE_END

#endif /* _cimple_Assoc2_Hnd_h */
