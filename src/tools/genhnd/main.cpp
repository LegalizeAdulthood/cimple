/*
**==============================================================================
**
** Copyright (c) 2003, 2004, 2005, 2006, Michael Brasher, Karl Schopmeyer
** 
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
** SOFTWARE.
**
**==============================================================================
*/

#include <cimple/config.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <getopt.h>
#include <cstdio>
#include <cctype>
#include <cstdlib>
#include <vector>
#include <set>
#include <cstdarg>
#include <string>
#include <util/util.h>
#include <tools/gencommon/gencommon.h>
#include "usage.h"
#include <mof/MOF_Parser.h>

using namespace std;

const char* arg0;
typedef set<string> Duplicate_Classes;
Duplicate_Classes duplicate_classes;
static vector<string> _generated_classes;
static FILE* _os = 0;
bool schema_opt = false;

size_t find(vector<string>& array, const string& x)
{
    for (size_t i = 0; i < array.size(); i++)
    {
        if (array[i] == x)
            return i;
    }

    return size_t(-1);
}

void append_unique(vector<string>& array, const string& x)
{
    size_t pos = find(array, x);

    if (pos == size_t(-1))
        array.push_back(x);
}

void print(vector<string>& array)
{
    for (size_t i = 0; i < array.size(); i++)
        printf("[%s]\n", array[i].c_str());
}

void nl()
{
    fputc('\n', _os);
}

static
CIMPLE_PRINTF_ATTR(1, 2)
void out(const char* format, ...)
{
    va_list ap;
    va_start(ap, format);
    vfprintf(_os, format, ap);
    va_end(ap);
}

static inline const char* _to_string(int data_type)
{
    if (data_type == TOK_STRING)
        return "String";
    else if (data_type == TOK_DATETIME)
        return "Datetime";

    return MOF_Data_Type::to_string(data_type);
}

//BOOKMARK

void gen_comment_line(size_t n)
{
    n -= 2;
    out("//");

    for (size_t i = 0; i < n; i++)
        fputc('=', _os);

    out("\n");
}

void gen_comment_block()
{
    gen_comment_line(80);
    out("//\n");
    out("// PLEASE DO NOT EDIT THIS FILE; IT WAS ");
    out("AUTOMATICALLY GENERATED BY GENCLASS.\n");
    out("//\n");
    gen_comment_line(80);
}

void gen_handle_decl(const MOF_Class_Decl* cd, bool ref)
{
    // Root class name:

    const char* rcn;

    if (ref)
        rcn = "Reference";
    else
        rcn = "Handle";

    // Class name:

    string cn = string(cd->name) + string("_") + rcn;

    // Super class name:

    string scn;
    
    if (cd->super_class)
        scn = string(cd->super_class->name) + string("_") + rcn;
    else
        scn = rcn;

    // Class header:

    out("class %s : public %s\n", cn.c_str(), scn.c_str());

    // Class body:

    out("{\n");
    out("public:\n");
    nl();

    out("    typedef %s Class;\n", cd->name);
    out("    typedef %s_Reference REFERENCE;\n", cd->name);
    nl();

    out("    %s();\n", cn.c_str());
    nl();

    out("    %s(const %s& x);\n", cn.c_str(), cn.c_str());
    nl();

    out("    %s(%s* inst);\n", cn.c_str(), cd->name);
    nl();

    out("    template<class CLASS>\n");
    out("    explicit %s(const CLASS& x);\n", cn.c_str());
    nl();

    out("    ~%s();\n", cn.c_str());
    nl();

    out("    %s& operator=(const %s& x);\n", cn.c_str(), cn.c_str());

    const MOF_Feature* p = cd->features;

    for (; p; p = (const MOF_Feature*)p->next)
    {
        const char* fn = p->name;

        // Skip non-keys?

        if (ref && !(p->qual_mask & MOF_QT_KEY))
            continue;

        // Property.

        const MOF_Property_Decl* prop = 
            dynamic_cast<const MOF_Property_Decl*>(p);

        if (prop)
        {
            nl();
            out("    // %s:\n", fn);

            if (prop->qual_mask & MOF_QT_EMBEDDEDOBJECT)
            {
                out("    Handle get_%s() const;\n", fn);
                out("    void set_%s(const Handle& x);\n", fn);
            }
            else
            {
                const char* pt = _to_string(prop->data_type);

                string t;

                if (prop->array_index == 0)
                    t = pt;
                else
                    t = "Array_" + string(pt);

                out("    const Property<%s>& get_%s() const;\n", t.c_str(), fn);
                out("    void set_%s(const %s& x);\n", fn, t.c_str());
                out("    void clear_%s();\n", fn);
            }

            continue;
        }

        // Reference?

        const MOF_Reference_Decl* ref = 
            dynamic_cast<const MOF_Reference_Decl*>(p);

        if (ref)
        {
            nl();
            out("    // %s:\n", fn);
            out("    %s_Reference get_%s() const;\n", ref->class_name, fn);
            out("    void set_%s(const %s_Reference& x);\n", 
                fn, ref->class_name);
            continue;
        }
    }

    out("};\n");

    nl();
}

void gen_handle_def(const MOF_Class_Decl* cd, bool ref)
{
    // Root class name:

    const char* rcn;

    if (ref)
        rcn = "Reference";
    else
        rcn = "Handle";

    // Class name:

    string cn = string(cd->name) + string("_") + rcn;

    // Super class name:

    string scn;
    
    if (cd->super_class)
        scn = string(cd->super_class->name) + string("_") + rcn;
    else
        scn = rcn;

    // T::T()

    out("inline %s::%s()\n", cn.c_str(), cn.c_str());
    out("{\n");
    out("    _inst = %s::create(true);\n", cd->name);

    if (cd->qual_mask & MOF_QT_ASSOCIATION)
        out("    __create_refs(_inst);\n");

    out("}\n");
    nl();

    // T::T(const T& x)

    out("inline %s::%s(const %s& x) : %s(x)\n", 
        cn.c_str(), cn.c_str(), cn.c_str(), scn.c_str());
    out("{\n");
    out("}\n");
    nl();

    // T::T(const I* inst)

    out("inline %s::%s(%s* inst)\n", cn.c_str(), cn.c_str(), cd->name);
    out("{\n");
    out("    _inst = inst;\n");

    if (cd->qual_mask & MOF_QT_ASSOCIATION)
        out("    __create_refs(_inst);\n");

    out("}\n");
    nl();

    // T::T(const CLASS& x)

    out("template<class CLASS>\n");
    out("inline %s::%s(const CLASS& x)\n", cn.c_str(), cn.c_str());
    out("{\n");
    out ("    _construct(*this, Class::static_meta_class, x);\n");
    out("}\n");
    nl();

    // T::~T()

    out("inline %s::~%s()\n", cn.c_str(), cn.c_str());
    out("{\n");
    out("}\n");
    nl();

    // T& operator=(const T& x)

    out("inline %s& %s::operator=(const %s& x)\n", 
        cn.c_str(), cn.c_str(), cn.c_str());
    out("{\n");
    out("    %s::operator=(x);\n", scn.c_str());
    out("    return *this;\n");
    out("}\n");
    nl();

    // Features.

    const MOF_Feature* p = cd->features;

    for (; p; p = (const MOF_Feature*)p->next)
    {
        const char* fn = p->name;

        // Skip non-keys?

        if (ref && !(p->qual_mask & MOF_QT_KEY))
            continue;

        // Property.

        const MOF_Property_Decl* prop = 
            dynamic_cast<const MOF_Property_Decl*>(p);

        if (prop)
        {
            if (prop->qual_mask & MOF_QT_EMBEDDEDOBJECT)
            {
                out("inline Handle %s::get_%s() const\n", cn.c_str(), fn);
                out("{\n");
                out("    ref(((%s*)_inst)->%s);\n", cd->name, fn);
                out("    return Handle(((%s*)_inst)->%s);\n", cd->name, fn);
                out("}\n");
                nl();

                out("inline void %s::set_%s(const Handle& x)\n", cn.c_str(),fn);
                out("{\n");
                out("    _cow();\n");
                out("    unref(((%s*)_inst)->%s);\n", 
                    cd->name, fn);
                out("    ref(((%s*)_inst)->%s = (Instance*)x.instance());\n",
                    cd->name, fn);
                out("}\n");
                nl();

                continue;
            }
            else
            {
                const char* pt = _to_string(prop->data_type);

                string t;

                if (prop->array_index == 0)
                    t = pt;
                else
                    t = "Array_" + string(pt);

                out("inline const Property<%s>& %s::get_%s() const\n", 
                    t.c_str(), cn.c_str(), fn);
                out("{\n");
                out("    return ((%s*)_inst)->%s;\n", cd->name, fn);
                out("}\n");
                nl();

                out("inline void %s::set_%s(const %s& x)\n", 
                    cn.c_str(), fn, t.c_str());
                out("{\n");
                out("    _cow();\n");
                out("    ((%s*)_inst)->%s.null = false;\n", cd->name, fn);
                out("    ((%s*)_inst)->%s.value = x;\n", cd->name, fn);
                out("}\n");
                nl();

                out("inline void %s::clear_%s()\n", cn.c_str(), fn);
                out("{\n");
                out("    _cow();\n");
                out("    ((%s*)_inst)->%s.null = true;\n", cd->name, fn);
                out("    __clear(((%s*)_inst)->%s.value);\n", cd->name, fn);
                out("}\n");
                nl();
            }

            continue;
        }

        // Reference?

        const MOF_Reference_Decl* ref = 
            dynamic_cast<const MOF_Reference_Decl*>(p);

        if (ref)
        {
            out("inline %s_Reference %s::get_%s() const\n", 
                ref->class_name, cn.c_str(), fn);
            out("{\n");
            out("    ref(((%s*)_inst)->%s);\n", cd->name, fn);
            out("    return %s_Reference(((%s*)_inst)->%s);\n", 
                ref->class_name, cd->name, fn);
            out("}\n");
            nl();

            out("inline void %s::set_%s(const %s_Reference& x)\n", 
                cn.c_str(), fn, ref->class_name);
            out("{\n");
            out("    _cow();\n");
            out("    unref(((%s*)_inst)->%s);\n", 
                cd->name, fn);
            out("    ref(((%s*)_inst)->%s = (%s*)x.instance());\n",
                cd->name, fn, ref->class_name);
            out("}\n");
            nl();

            continue;
        }
    }
}

void gen_ref_includes(const MOF_Class_Decl* cd)
{
    MOF_Feature* p = cd->features;

    for (; p; p = (MOF_Feature*)p->next)
    {
        MOF_Reference_Decl* ref = dynamic_cast<MOF_Reference_Decl*>(p);

        if (ref)
            out("#include \"%s_Handle.h\"\n", ref->class_name);
    }
}

void gen_param_ref_includes(const MOF_Class_Decl* cd)
{
    MOF_Feature* p = cd->features;

    for (; p; p = (MOF_Feature*)p->next)
    {
        MOF_Method_Decl* meth = dynamic_cast<MOF_Method_Decl*>(p);

        if (!meth)
            continue;

        for (MOF_Parameter* q = meth->parameters; q; q =(MOF_Parameter*)q->next)
        {
            if (q->data_type == TOK_REF)
                out("#include \"%s_Handle.h\"\n", q->ref_name);
        }
    }
}

void gen_header_file(const MOF_Class_Decl* cd)
{
    gen_comment_block();
    nl();

    out("#ifndef _cimple_%s_Handle_h\n", cd->name);
    out("#define _cimple_%s_Handle_h\n", cd->name);
    nl();

    out("#include <cimple/cimple.h>\n");

    out("#include \"%s.h\"\n", cd->name);

    if (cd->super_class)
        out("#include \"%s_Handle.h\"\n", cd->super_class->name);

    gen_ref_includes(cd);
    gen_param_ref_includes(cd);
    nl();

    out("CIMPLE_NAMESPACE_BEGIN\n");
    nl();

    gen_handle_decl(cd, true);
    gen_handle_decl(cd, false);
    gen_handle_def(cd, true);
    gen_handle_def(cd, false);

    out("CIMPLE_NAMESPACE_END\n");
    nl();

    out("#endif /* _cimple_%s_Handle_h */\n", cd->name);
}

static const MOF_Class_Decl* _find_class(const string& class_name)
{
    const MOF_Class_Decl* cd = 
        MOF_Class_Decl::find((char*)class_name.c_str());

    if (!cd)
    {
        err("error: no such class: \"%s\"", class_name.c_str());
        exit(1);
    }

    return cd;
}

void gen_class(const char* class_name)
{
    void gen_ancestor_classes(const char* class_name);
    void gen_ref_clases(const char* class_name);
    void gen_param_ref_clases(const char* class_name);

    // Avoid generating any class more than once:

    if (duplicate_classes.find(class_name) != duplicate_classes.end())
        return;

    duplicate_classes.insert(class_name);

    // First generate any ancestor classes:

    gen_ancestor_classes(class_name);

    // Now generate any ref classes (any classes that associations refer to).

    gen_ref_clases(class_name);

    // Now generate any param ref classes.

    gen_param_ref_clases(class_name);

    // Find the class.

    const MOF_Class_Decl* cd = _find_class(class_name);

    // Remember all generated classes:

    _generated_classes.push_back(class_name);

    // Generate header file:
    {
        char path[1024];
        sprintf(path, "%s_Handle.h", class_name);
        
        if ((_os = fopen(path, "wb")) == NULL)
            err("error: cannot open \"%s\"", path);

        gen_header_file(cd);

        fclose(_os);
        printf("Created %s\n", path);
    }
}

void gen_ancestor_classes(const char* class_name)
{
    const MOF_Class_Decl* cd = _find_class(class_name);
    const MOF_Class_Decl* scd = cd->super_class;

    if (!scd)
        return;

    gen_ancestor_classes(scd->name);
    gen_class(scd->name);
}

void gen_ref_clases(const char* class_name)
{
    const MOF_Class_Decl* cd = _find_class(class_name);
    MOF_Feature* p = cd->features;

    for (; p; p = (MOF_Feature*)p->next)
    {
        MOF_Reference_Decl* ref = dynamic_cast<MOF_Reference_Decl*>(p);

        if (ref)
            gen_class(ref->class_name);
    }

    return;
}

void gen_param_ref_clases(const char* class_name)
{
    const MOF_Class_Decl* cd = _find_class(class_name);
    MOF_Feature* p = cd->features;

    for (; p; p = (MOF_Feature*)p->next)
    {
        MOF_Method_Decl* meth = dynamic_cast<MOF_Method_Decl*>(p);

        if (!meth)
            continue;

        for (MOF_Parameter* q = meth->parameters; q; q =(MOF_Parameter*)q->next)
        {
            if (q->data_type == TOK_REF)
                gen_class(q->ref_name);
        }
    }
}

int main(int argc, char** argv)
{
    arg0 = argv[0];
    set_arg0(arg0);
    vector<string> mof_files;
    vector<string> extra_mof_files;

    // Add the current directory to the search path:

    MOF_include_paths[MOF_num_include_paths++] = ".";

    // Process command-line options.

    for (int opt; (opt = getopt(argc, argv, "I:M:Vhs")) != -1; )
    {
        switch (opt)
        {
            case 'I':
            {
                if (!optarg)
                {
                    err("missing argument on -I option");
                    exit(1);
                }

                if (MOF_num_include_paths == MAX_INCLUDES)
                {
                    err("too many -I options");
                    exit(1);
                }

                MOF_include_paths[MOF_num_include_paths++] = optarg;
                break;
            }

            case 'M':
            {
                if (!optarg)
                {
                    err("missing argument on -M option");
                    exit(1);
                }

                extra_mof_files.push_back(optarg);
                break;
            }

            case 'h':
                printf((char*)USAGE);
                exit(0);
                break;

            case 'V':
                printf("%s\n", CIMPLE_VERSION_STRING);
                exit(0);
                break;

            case 's':
                schema_opt = true;
                break;

            default:
                err("invalid option: %c; try -h for help", opt);
                break;
        }
    }

    // We expect at least one argument (or -c option)

    if (optind == argc && !schema_opt)
    {
        printf((char*)USAGE);
        exit(1);
    }

    // Setup the MOF include path.

    setup_mof_path();

    // Load the repository:

    load_repository(extra_mof_files);

    // Generate classes:

    vector<string> classes;

    for (int i = optind; i < argc; i++)
        append_unique(classes, argv[i]);

    if (schema_opt)
    {
        // Generate entire CIM schema:

        for (const MOF_Class_Decl* p = MOF_Class_Decl::list;
            p;
            p = (const MOF_Class_Decl*)(p->next))
        {
            gen_class(p->name);
        }

        exit(0);
    }

    for (size_t i = 0; i < classes.size(); i++)
        gen_class(classes[i].c_str());

    return 0;
}

