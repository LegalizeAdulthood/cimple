/*
**==============================================================================
**
** Copyright (c) 2003, 2004, 2005, 2006, Michael Brasher, Karl Schopmeyer
** 
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
** SOFTWARE.
**
**==============================================================================
*/

/*
    Implements logging for CIMPLE.
    Logs can be generated by CIMPLE provider writers using the macros
    in log.h and also by the various adapters using the mechanisms in
    AddapterTracer.h.
    log.cpp writes all logs to a single messages file defined to be in
    a directory defined by an environment variable so that the user
    can place it where required at runtime.
    The log mechanism includes the capability to set maximum size on
    logs and then to either restart the log file or create backup files.
    The runtime configuration parameters for logging include:
       - max number of backup files
       - max log file size
       - log enable/disable
       - log severities to be logged
    The compile time options that affect logging include:
       - Enable adapter traces
       - Enabling the log macros
    The log file modifications are protected by a mutex for multiple threads
    and by a file lock so that multiple processes could write to the
    same log file (The latter is required in the case of pegasus
    out of process logs)
 
    FUTURE TODO:
       - Enable logging by provider or provider module
       - Provide alternate outputs for logging
       - Possibly consider multiple log files by serverity or provider.
       - 
*/

#include <sys/stat.h>
#include <cctype>
#include <pthread.h>
#include "log.h"
#include "File_Lock.h"
#include "Buffer.h"
#include "Datetime.h"
#include "config.h"
#include "options.h"
#include "FileSystem.h"
#include "io.h"
#include <errno.h>

#ifdef CIMPLE_WINDOWS_MSVC
# include <windows.h>
# include <io.h>
# include <direct.h>
#endif

// Define the name for the directory that normally used by CIMPLE including
// for log output.  Also defines the prefix for the configuration file.
#define DEFAULT_CONFIG_FILE_NAME ".cimple"

// Temporary define to include code being used to test windows
// rollover which has a problem with rename. Remove comment
// from following line to test
//#define WINDOWS_TEMP_TEST

CIMPLE_NAMESPACE_BEGIN

// Define Environment Variable defining location of CIMPLE_HOME, the
// location where CIMPLE stores and retrieves information. This is set
// from a definitiion in config.h but may be overridded by setters
// in cimple_config.
static String cimple_home_envvar = CIMPLEHOME_ENVVAR ;

// FUTURE static String cimple_home_dir = String::EMPTY;

// When true, macro log calls are executed.  When false, the macro
// calls return immediatly without calling log generation functions
// Further, the vlog function does not execute so even direct log calls
// return without generating logs.  Setting this variable false completely
// disable logging
boolean _log_enabled_state = true;

static File_Lock* _file_lock;
static FILE* _log_file_handle = 0;

// current log level set by info from the config file or the log_set_level
// function. Determines which log calls actually generate log entries.
// Note that the minimum level is FATAL
static Log_Level _level;

// Maximum size of log file.  0 Means ignore the test and is the default
static uint32 _max_log_file_size = 0;

// define the maximum number of backup files that may exist in this
// environment
#define MAXIMUM_NUMBER_BACKUP_FILES 9

// maximum number of backup log files. 0 Means ignore test and is default
// This variable is set by the .cimplerc config file or the CimpleConfig
// set function. It must never be larger than MAXIMUM_NUMBER_BACKUP_FILES
static uint32 _max_log_backup_files = 0;

// defines whether log output has been initialized
static bool _initialized;

// size for log file
static uint32 _current_log_file_size = 0;

// path to config path once started
static char config_path[200];

// full path name of log file including file name.
static char log_file_path[1024];

// log mutex
static pthread_mutex_t _mutex = PTHREAD_MUTEX_INITIALIZER;

static const char* _log_level_strings[] =
{
    "FATAL",
    "ERR", 
    "WARN",
    "INFO",
    "DBG",
};

static const size_t _num_strings =
    sizeof(_log_level_strings) / sizeof(_log_level_strings[0]);

//*************************************************************
// Define a macro to generate output for errors in creation and 
// handling of the log files.  This is special because the normal
// output is the log and if there are issues with the log there
// is nowhere to output the information.  Only active in debug
// mode and outputs a simple printf so that info is only visible
// when provider operating in forground.
// THIS IS USED ONLY BY THE log.cpp module to generate info about
// errors in log file handling.
// ex.
// LOG_ERR(("Cannot create log file\n"));
//***************************************************************
#ifdef CIMPLE_DEBUG
// internal function to output errors in Log file handling.

    //CIMPLE_PRINTF_ATTR(3, 4) // generates warning flag
static void  _log_err_output(
    const char* file,
    size_t line, 
    const char* fmt,
    va_list ap)
{
    Buffer buffer;
    // TODO Add time to this possibly
    buffer.vformat(fmt, ap);
    printf("LOG FILE ERROR %s(%zd) : %s\n",file, line,
       buffer.data());
}

// struct define frame that contains output info and
// invoke method to execute
struct Log_Err_Call_Frame
{
    const char* file;
    size_t line;

    // holds line number of call
    Log_Err_Call_Frame(const char* file_, size_t line_) : 
        file(file_), line(line_) { }
    
    //CIMPLE_PRINTF_ATTR(1, 2) generates error on linux
    inline void invoke(const char* format, ...) 
    {
        va_list ap;
        va_start(ap, format);
        _log_err_output(file, line, format, ap);
        va_end(ap);
    }
};
# define LOG_ERR(ARGS) \
    do \
    { \
        Log_Err_Call_Frame frame(__FILE__,__LINE__); \
        frame.invoke ARGS ; \
    } \
    while (0)
#else
# define LOG_ERR(ARGS)
#endif


//*************************************************************
//
// Handlers for reading the configuration file
// 
// ************************************************************

static char* _get_opt_value(const char* path, const char* opt)
{
    size_t opt_len = strlen(opt);

    // Open file.

    FILE* is = fopen(path, "r");

    if (!is)
        return 0;

    // Scan file looking for option.

    char buffer[1024];

    while (fgets(buffer, sizeof(buffer), is) != 0)
    {
        char* p = buffer;
        // trim leading whitespace
        while (*p && isspace(*p))
            p++;

        // skip lines starting with comment character including
        // after leading whitespace
        if (buffer[0] == '#')
            continue;

        // Trim trailing whitespace.
        while (*p)
            p++;

        while (p != buffer && isspace(p[-1]))
            *--p = '\0';

        // Skip blank lines.

        if (buffer[0] == '\0')
            continue;

        // Check for name defined by opt.

        if (strncmp(buffer, opt, opt_len) == 0)
        {
            const char* p = buffer + opt_len;

            while (isspace(*p))
                p++;

            if (*p == '=')
            {
                p++;

                while (isspace(*p))
                    p++;

                fclose(is);
                return strdup(p);
            }
        }
    }
    fclose(is);

    return 0;
}

// validate the text provided against the possible log level
// string definitions.  Return 0 if valid with the correct enum
// in level or -1 if no match.
// Does a no case match against the level definition strings.
// Returns 0 if txt matches one of the defined log_level strings and
// also the level.
// @return 0 if OK else -1
static int _validate_log_level(const char * txt, Log_Level& level)
{
    for (size_t i = 0; i < _num_strings; i++)
    {
        if (strcasecmp(_log_level_strings[i], txt) == 0)
        {
            level = Log_Level(i);
            return 0;
        }
    }
    return -1;   // return invalid
}

// get the log level string definition from the
// config file and if it is valid return 0.  If it is invalid
// return -1. If variable not in file, return 1;
static int _get_log_level(const char* path, Log_Level& level)
{
    char* value_str = _get_opt_value(path, "LOG_LEVEL");
    
    // return variable not in file status
    if (!value_str)
        return 1;

    int rtn = _validate_log_level(value_str, level);

    free(value_str);
    return rtn;
}

// Get a Uint32 value corresponding to the option name "name".  If the
// name is not found
static int _get_log_opt_uint32(const char* path,
                               const char * name,
                               uint32& value)
{
    char * value_str = _get_opt_value(path, name);
    if (!value_str)
    {
        return 1;
    }
    sint64 temp;
    char* end;

    temp = strtol(value_str, &end, 0);

    if (temp < 0 || (temp > CIMPLE_UINT32_MAX) || (*end != '\0'))
    {
        return -1;
    }
    value = (uint32)temp;
    free(value_str);
    return 0;
}

static int _get_log_opt_bool(const char* path,
                             const char * name,
                             bool& value)
{
    char * value_str = _get_opt_value(path, name);
    if (!value_str)
    {
        return 1;
    }
    if (strcasecmp(value_str, "TRUE") == 0)
    {
        value = true;
    }
    else if (strcasecmp(value_str, "FALSE") == 0)
    {
        value = false;
    }
    else
        return -1;

    free(value_str);
    return 0;
}

// get the new value for the max_log_file_size parameter
static int _get_log_maxLogFileSize_param(const char* path, uint32& rtnValue)
{
    return(_get_log_opt_uint32(path, "MAX_LOG_FILE_SIZE", rtnValue));
}

static int _get_log_maxLogBackupFiles_param(const char* path, uint32& rtnValue)
{
    return(_get_log_opt_uint32(path, "MAX_LOG_BACKUP_FILES", rtnValue));
}

static int _get_log_enable_param(const char* path, bool& rtnValue)
{
    return(_get_log_opt_bool(path, "ENABLE_LOGGING", rtnValue));
}

// Read config file for each defined name=value pair.  Any error aborts
// the read.
int _read_config(char * conf_path)
{
    if (_get_log_level(conf_path, _level) == -1)
        return -1;

    if (_get_log_maxLogFileSize_param(conf_path, _max_log_file_size) == -1)
        return -1;

    if (_get_log_maxLogBackupFiles_param(conf_path, _max_log_backup_files) == -1)
        return -1;

    if( _get_log_enable_param(conf_path, _log_enabled_state) == -1)
        return -1;

    return 0;
}

//*********************************************************************
//
//  Log initialization and roll over functions
//
//********************************************************************

// Initialize the log files using status from the config file if
// it exists. The name of the config file is defined by the
// name variable on input.
static void _initialize(const char* name)
{
    if (_initialized)
    {
        return;
    }
    // Get home path for CIMPLE_HOME.
    // Defined originally in options as define and 
    // as String in this file.
   
    const char* home = getenv(cimple_home_envvar.c_str());

    if (!home)
        return;

    // Read parameters from .<name>rc configuration file.
    char conf_path[1024];

    sprintf(conf_path, "%s/%src", home, name);

    // WARNING: errors here are not really caught since the only way
    // to display is the log and these represent a log error.
    if (_read_config(conf_path) == -1)
        return;

    // Create $HOME/.cimple directory.

    char root_path[1024];
    {
        sprintf(root_path, "%s/%s", home, name);
#ifdef CIMPLE_WINDOWS_MSVC
        _mkdir(root_path);
#else
        mkdir(root_path, 0777);
#endif
    }

    // Form path to log file:

    {
        strlcpy(log_file_path, root_path, sizeof(log_file_path));
        strlcat(log_file_path, "/messages", sizeof(log_file_path));
    }

    // Form path to lock file:

    char lock_file_path[1024];
    {
        strlcpy(lock_file_path, root_path, sizeof(log_file_path));
        strlcat(lock_file_path, "/messages.lock", sizeof(lock_file_path));
    }

    // Create file lock object if it does not already exist

    if (!_file_lock)
    {
        _file_lock = new File_Lock(lock_file_path);
    }
    
    // Fail if cannot create lock file.  This is the out if everything
    // fails.
    if (!_file_lock->okay())
    {
      delete _file_lock;
      _file_lock = 0;
      LOG_ERR(("log file lock create error %s", lock_file_path));
      return;
    }

    // initialize _log_file_size by getting size of file and putting
    // it into the variable
    // TODO why are we both setting to zero anc getting from FILE??
    _current_log_file_size = 0;
    FileSystem::get_size(log_file_path, _current_log_file_size);

    // Open log file for append.
    // The handle should always be zero here or we are reopening 
    // the file which messes up close/rename for windows systems.
    CIMPLE_ASSERT(_log_file_handle == 0);
    _log_file_handle = fopen(log_file_path, "a");

    // If cannot create log file, 
    if (!_log_file_handle)
    {
        delete _file_lock;
        _file_lock = 0;
        LOG_ERR(("Log file open error %s", log_file_path));
        return;
    }
    _initialized = true;
}

// create a file path name from _log_file_path with the suffix .<number>
String _create_backup_file_name(uint32 number)
{
    String rtn_file_name = string_printf("%s.%u", log_file_path, number);
    return rtn_file_name;
}

bool _delete_log_backup_file(uint32 number)
{
    String delete_file_name = _create_backup_file_name(number);

    if (FileSystem::exists(delete_file_name.c_str()))
    {
        if (!FileSystem::delete_file(delete_file_name.c_str()))
        {
            LOG_ERR(("ERROR: log backup file %s not deleted\n",
                    delete_file_name.c_str()));
            return false;
        }
    }
    return true;
}
void _log_file_close()
{
    if (!(fclose(_log_file_handle) == 0))
    {
        LOG_ERR(("ERROR: log file close failed. Error = %s\n",
             strerror(errno)));
    }
    _log_file_handle = 0;
}

// Close log file and delete all current log files.
bool _delete_all_log_files()
{
    pthread_mutex_lock(&_mutex);
    bool rtn = true;
    // lock file to prevent other process from touching
    // while we delete.
    if (_file_lock)
    {
        _file_lock->lock();
    }
    // Delete the current file (messages) if it exists
    if (FileSystem::exists(log_file_path))
    {
        _log_file_close();
        if(!FileSystem::delete_file(log_file_path))
        {
            LOG_ERR(("Log file %s not deleted\n", log_file_path));
            pthread_mutex_unlock(&_mutex);
            return false;
        }
    }
    // Delete any backup files up to the max allowed
    for (uint32 i = 1; i < MAXIMUM_NUMBER_BACKUP_FILES; i++)
    {
        String fName = _create_backup_file_name(i);
        if (FileSystem::exists(fName.c_str()))
        {
            if (!_delete_log_backup_file(i))
                rtn = false;
        }
    }
    if (_file_lock)
    {
        _file_lock->unlock();
    }
    pthread_mutex_unlock(&_mutex);
    return rtn;
}

// Rename a backup file from filename.n to filename.(n+1)
// TODO - There should be a cheaper way where we only create a filename
// one time.
bool _rename_log_backup_file(uint32 number)
{
    String from = _create_backup_file_name(number);
    String to = _create_backup_file_name((number+1));

    // NOTE: No error flagged if the from file does not exist.
    if (FileSystem::exists(from.c_str()))
    {
        if (!FileSystem::rename_file(from.c_str(), to.c_str()))
        {
            LOG_ERR(("ERROR: log file rename failed from %s to %s\n",
                   from.c_str(), to.c_str()));
            return false;
        }
    }
    return true;
}
// Called when the log file reaches a predefined length.  Closes the
// file, renames it to *.1, renames all older files, and opens a
// new log file. This function called from vlog and operates under
// the protection of that mutex and filelock. 
void _rollover_log_file()
{
    // close the existing log file
    _log_file_close();

    // rename any existing old log files
    if(_max_log_backup_files != 0)
    {
        // delete the oldest log file if it exists.
        _delete_log_backup_file(_max_log_backup_files);

        // rename all log backup files from name.n to name.n+1
        for (uint32 i = (_max_log_backup_files - 1) ; i > 0 ; i--)
        {
            if (!_rename_log_backup_file(i))
            {
                LOG_ERR(("Renaming log file %s\n", 
                       _create_backup_file_name(i).c_str()));
            }
        }

        // rename current file to filename.1
        String newFileName = _create_backup_file_name(1);

        if(!FileSystem::rename_file(log_file_path, newFileName.c_str()))
        {
           LOG_ERR(("Renaming log file %s to %s. error = %s\n",
                   log_file_path, newFileName.c_str(), strerror(errno)));
        }
    }
    else
        // If maximum log backups == 0, just delete file.
        FileSystem::delete_file(log_file_path);

    // reinitialize log file
    // KS_TODO - need to break up initialize so we just do the essential
    // open log parts here.
    _initialized = false;
    _initialize(DEFAULT_CONFIG_FILE_NAME);
}

// Commented out because not used.
//void open_log(const char* name)
//{
//    // Initialize on the first call.
//
//    if (!_initialized)
//    {
//        _initialize(name);
//    }
//}

//******************************************************************
// 
// log output functions log and vlog).  These should not be used directly
// by CIMPLE providers. Use the macros defined in log.h
// 
//******************************************************************
// This function is the interface to the log output.  It is mutexed and
// both formats the log information and outputs it to the log file.
void vlog(
    Log_Level level, 
    const char* file, 
    size_t line, 
    const char* fmt,
    va_list ap)
{
    pthread_mutex_lock(&_mutex);

    // Initialize from the .cimplerc config file on the first call.

    //printf("vlog _log_file_handle vlog = %p\n", _log_file_handle);
    if (!_initialized)
    {
        _initialize(DEFAULT_CONFIG_FILE_NAME);
    }

    // Bail out if initialize failed. This is a permanent test so that
    // all logging is disabled if we cannot initialize the file.

    if (!_log_file_handle)
    {
        pthread_mutex_unlock(&_mutex);
        return;
    }

    // If _log_enabled_state false, disable all logging or
    // log level for this log higher than currently enabled level
    if (!_log_enabled_state  || (level > _level))
    {
        pthread_mutex_unlock(&_mutex);
        return;
    }

    // Format time string:

    char datetime[Datetime::BUFFER_SIZE];
    {
        Datetime dt = Datetime::now();
        dt.ascii(datetime, true);
        char* dot = strchr(datetime, '.');

        if (dot)
            *dot = '\0';
    }

    // Format message prefix:

    Buffer buffer;
    buffer.format("%s %s: %s(%d): ", datetime, _log_level_strings[int(level)], 
        file, (uint32)line);

    // Format message body:

    buffer.vformat(fmt, ap);

    if (buffer[buffer.size()-1] != '\n')
        buffer.append('\n');

    // Test for log file size limits and if exceeded, roll 
    // current file over, to create backup log files
    // If max log file size == 0 ignore the max.

    if ((_max_log_file_size != 0) && 
        (_current_log_file_size > _max_log_file_size))
    {
        // Role the log file to backup file within a file lock.
        _file_lock->lock();
        _rollover_log_file();
        _file_lock->unlock();
    }

    // track log file size by accumulating from buffer
    _current_log_file_size += buffer.size();

    // Write to log file within file lock
    _file_lock->lock();
    fwrite(buffer.data(), buffer.size(), 1, _log_file_handle);
    fflush(_log_file_handle);
    _file_lock->unlock();

    pthread_mutex_unlock(&_mutex);
}

void log(Log_Level level, const char* file, size_t line, const char* fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vlog(level, file, line, fmt, ap);
    va_end(ap);
}

//************************************************************************
//
//  Functions to set/get log configuration information.  These should
//  only be used internally by CIMPLE (See CimpleConfig.h for functions
//  to be used by the provider writer.
//
//************************************************************************

// sets the log level based on the input string provided.
// returns 0 if successful or -1 if the string is invalid.
bool log_set_level(String& level)
{
    // try to set the new state and return result
    return(_validate_log_level(level.c_str(), _level));
}

CIMPLE_CIMPLE_LINKAGE
bool log_set_level(Log_Level level)
{
    _level = level;
    return 0;
}

CIMPLE_CIMPLE_LINKAGE
Log_Level log_get_level()
{
    return _level;
}

CIMPLE_CIMPLE_LINKAGE
const char * log_get_level_string()
{
    return _log_level_strings[_level];
}

uint32 log_get_maxFileSize()
{
    return _max_log_file_size;
}

bool log_set_maxlogFileSize(uint32 new_size)
{
    _max_log_file_size = new_size;
    return true;
}

uint32 log_get_maxLogBackupFiles()
{
    return _max_log_backup_files;
}

bool log_set_maxlogBackupFiles(uint32 new_size)
{
    if (new_size <= MAXIMUM_NUMBER_BACKUP_FILES)
    {
        _max_log_backup_files = new_size;
        return true;
    }
    else
        return false;
}

bool log_enable(bool x)
{
    bool rtn = _log_enabled_state;
    _log_enabled_state = x;
    return rtn;
}
bool get_log_enable_state()
{
    return _log_enabled_state;
}

CIMPLE_CIMPLE_LINKAGE
int set_cimple_home_envvar(const char* env_var)
{
    cimple_home_envvar = env_var;
    return 0;
}

const char* get_cimple_home_envvar()
{
    return cimple_home_envvar.c_str();
}

CIMPLE_CIMPLE_LINKAGE
void log_reinitialize()
{
    pthread_mutex_lock(&_mutex);
    if (_file_lock)
    {
        _file_lock->lock();
    }
    if (_log_file_handle)
    {
        _log_file_close();
    }
    _initialized = false;
    _initialize(DEFAULT_CONFIG_FILE_NAME);
    _file_lock->unlock();
    pthread_mutex_unlock(&_mutex);
}

CIMPLE_CIMPLE_LINKAGE
bool log_remove_all_logfiles()
{
    return _delete_all_log_files();
}

bool read_config_file()
{
    // To reread the config file we force complete
    // reinitialization of the log.
    log_reinitialize();
    return true;
}

CIMPLE_NAMESPACE_END
