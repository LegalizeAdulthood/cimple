// Generated by genprov 2.0.1
#include "CIMPLE_ExceptionLink_Provider.h"

/*
    This test provider is set up to return specific exception responses
    based on definitions provided by an input method.  The goal of this
    provider is simply to confirm the error code paths through the
    various adapters and assure that we are returning the correct 
    error codes.  It never actually returns any instances.
*/

CIMPLE_NAMESPACE_BEGIN

CIMPLE_ExceptionLink_Provider::CIMPLE_ExceptionLink_Provider()
{
}

CIMPLE_ExceptionLink_Provider::~CIMPLE_ExceptionLink_Provider()
{
}

Load_Status CIMPLE_ExceptionLink_Provider::load()
{
    return LOAD_OK;
}

Unload_Status CIMPLE_ExceptionLink_Provider::unload()
{
    return UNLOAD_OK;
}

Get_Instance_Status CIMPLE_ExceptionLink_Provider::get_instance(
    const CIMPLE_ExceptionLink* model,
    CIMPLE_ExceptionLink*& instance)
{
    //
    // if the default flag set, return unsupported
    // 
    
    if (_getInstanceDefault)
    {
        printf("CIMPLE_ExceptionLink get_instance using default return\n");
        return GET_INSTANCE_UNSUPPORTED;
    }

    //
    // Execute return code based on the current _exception code provided
    //
    Get_Instance_Status status = (Get_Instance_Status)_exception;

    printf("CIMPLE_ExceptionLink get_instance status = %u\n", status);

    switch (status)
    {
        case GET_INSTANCE_NOT_FOUND:
        case GET_INSTANCE_UNSUPPORTED:
        case GET_INSTANCE_ACCESS_DENIED:
        case GET_INSTANCE_FAILED:
        case GET_INSTANCE_INVALID_PARAMETER:
            return status;
            break;

        // should never be using this case.
        case GET_INSTANCE_OK:
            CIMPLE_ExceptionLink* link = CIMPLE_ExceptionLink::create();
            link->left = CIMPLE_Exception::create();
            link->left->Key.value = 1;
        
            link->right = CIMPLE_Exception::create();
            link->right->Key.value = 1;

            return GET_INSTANCE_OK;
            break;
    }
    printf("ERROR: get_instance received invalid code %u\n", _exception);
    return GET_INSTANCE_FAILED;
}

Enum_Instances_Status CIMPLE_ExceptionLink_Provider::enum_instances(
    const CIMPLE_ExceptionLink* model,
    Enum_Instances_Handler<CIMPLE_ExceptionLink>* handler)
{
    Enum_Instances_Status status = (Enum_Instances_Status)_exception;
    printf("CIMPLE_ExceptionLink get_instance status = %u\n", status);
    switch (status)
    {
        case ENUM_INSTANCES_OK:
        case ENUM_INSTANCES_FAILED:
        case ENUM_INSTANCES_ACCESS_DENIED:
            return status;
            break;
    }
    printf("enum_instance received invalid code %u\n", status);
    return ENUM_INSTANCES_FAILED;
}

Create_Instance_Status CIMPLE_ExceptionLink_Provider::create_instance(
    CIMPLE_ExceptionLink* instance)
{
    return CREATE_INSTANCE_UNSUPPORTED;
}

Delete_Instance_Status CIMPLE_ExceptionLink_Provider::delete_instance(
    const CIMPLE_ExceptionLink* instance)
{
    return DELETE_INSTANCE_UNSUPPORTED;
}

Modify_Instance_Status CIMPLE_ExceptionLink_Provider::modify_instance(
    const CIMPLE_ExceptionLink* model,
    const CIMPLE_ExceptionLink* instance)
{
    return MODIFY_INSTANCE_UNSUPPORTED;
}

Enum_Associator_Names_Status CIMPLE_ExceptionLink_Provider::enum_associator_names(
    const Instance* instance,
    const String& result_class,
    const String& role,
    const String& result_role,
    Enum_Associator_Names_Handler<Instance>* handler)
{
    //
    // if the default flag set, return unsupported
    // 
    
    if (_associatorsDefault)
    {
        printf("ENUM_ASSOCIATOR_NAMES using default return\n");
        return ENUM_ASSOCIATOR_NAMES_UNSUPPORTED;
    }
    Enum_Associator_Names_Status status = (Enum_Associator_Names_Status)_exception;
    printf("Enum_Associator_Names status = %u\n", status);
    switch (status)
    {
        case ENUM_ASSOCIATOR_NAMES_OK:
        case ENUM_ASSOCIATOR_NAMES_FAILED:
        case ENUM_ASSOCIATOR_NAMES_UNSUPPORTED:
        case ENUM_ASSOCIATOR_NAMES_ACCESS_DENIED:
            return status;
            break;
    }

    printf("Enum_Associator_Names received invalid code %u\n", status);
    return ENUM_ASSOCIATOR_NAMES_FAILED;
}

Enum_Associators_Status CIMPLE_ExceptionLink_Provider::enum_associators(
    const Instance* instance,
    const String& result_class,
    const String& role,
    const String& result_role,
    Enum_Associators_Handler<Instance>* handler)
{
    //
    // if the default flag set, do return unsupported
    // 
    
    if (_associatorsDefault)
    {
        printf("ENUM_ASSOCIATORS using default return\n");
        return ENUM_ASSOCIATORS_UNSUPPORTED;
    }

    //
    // if the default flag set, do return unsupported
    // 
    
    if (_associatorsDefault)
    {
        printf("ENUM_ASSOCIATORS using default return\n");
        return ENUM_ASSOCIATORS_UNSUPPORTED;
    }
    Enum_Associators_Status status = (Enum_Associators_Status)_exception;
    printf("ENUM_ASSOCIATORS status = %u\n", status);
    switch (status)
    {
        case ENUM_ASSOCIATORS_OK:
        case ENUM_ASSOCIATORS_FAILED:
        case ENUM_ASSOCIATORS_UNSUPPORTED:
        case ENUM_ASSOCIATORS_ACCESS_DENIED:
            return status;
            break;
    }

    printf("ENUM_ASSOCIATORS received invalid code %u\n", status);
    return ENUM_ASSOCIATORS_FAILED;
}

Enum_References_Status CIMPLE_ExceptionLink_Provider::enum_references(
    const Instance* instance,
    const CIMPLE_ExceptionLink* model,
    const String& role,
    Enum_References_Handler<CIMPLE_ExceptionLink>* handler)
{
    //
    // if the default flag set, do return unsupported
    // 
    
    if (_associatorsDefault)
    {
        printf("get_instance using default return\n");
        return ENUM_REFERENCES_UNSUPPORTED;
    }
    return ENUM_REFERENCES_UNSUPPORTED;
}

const char * _toChar(boolean x)
{
    return(x? "true" : "false");
}

Invoke_Method_Status CIMPLE_ExceptionLink_Provider::setException(
    const CIMPLE_ExceptionLink* self,
    const Property<uint32>& Exception,
    const Property<boolean>& getInstanceDefault,
    const Property<boolean>& associatorsDefault,
    Property<uint32>& return_value)

{
    printf("Enter setException\n");
    _exception = Exception.value;

    _getInstanceDefault = getInstanceDefault.value;

    _associatorsDefault = associatorsDefault.value;
   
    printf("setException  Exception Value = %u\n", _exception);
    printf("   getInstanceDefault Value = %s\n", _toChar(_getInstanceDefault));
    printf("   associatorsDefault Value = %s\n", _toChar(_associatorsDefault));

    CIMPLE_INFO(("setException  Exception Value = %u\n", _exception));
    return_value.set(0);

    return INVOKE_METHOD_OK;
}

Invoke_Method_Status CIMPLE_ExceptionLink_Provider::testException(
    const CIMPLE_ExceptionLink* self,
    Property<uint32>& return_value)

{
    return INVOKE_METHOD_UNSUPPORTED;
}

/*@END@*/

CIMPLE_NAMESPACE_END
